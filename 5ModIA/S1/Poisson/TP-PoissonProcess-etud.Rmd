---
title: "Introduction to Poisson processes with R"
author: "5 ModIA"
date: "2024/2025"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# 1 - Homogeneous Poisson processes observed on a fixed window

First, we consider the case of a fixed observation window (and thus a random number of events). 

## 1.1 - Simulation

Simulation of a homogeneous Poisson process with intensity `lambda` on the window [0,`Tmax`].
```{r simulPPh1,eval=FALSE}
simulPPh1 <- function(lambda,Tmax)
{
  N_tmax = rpois(1, lambda*Tmax)
  
  unif = runif(N_tmax, 0, Tmax)
  unif = sort(unif)
  
  return(unif)
}
```

Let us define a plot function for a counting process `PP`. 
```{r plot.PP}
plot.PP<- function(PP)
{
  # plot the counting process (with jumps of size 1 (starting at point (0,0))):
  plot(c(0,PP),0:length(PP),type="s",xlab="time t",ylab="number of events by time t")
  # add the arrival times on the horizontal axis: 
  points(PP,0*PP,type="p",pch=16)
  # link arrival times with the counts:
  lines(PP,0:(length(PP)-1),type="h",lty=2)
}
```

```{r,eval=FALSE}
# Simulation and plot of a homogeneous Poisson process:
PPh1 = simulPPh1(2,100)
plot.PP(PPh1)
```


## 1.2 - Maximum Likelihood Estimator (MLE)

Maximum Likelihood estimator of a homogeneous Poisson process `PPh` observed on [0,`Tmax`]:
```{r MLE1,eval=FALSE}
MLE1 <- function(PPh,Tmax)
{
  return(length(PPh)/Tmax)
}
```

```{r,eval=FALSE}
MLE1(PPh1, 100)
```

Comment: On fluctue autour de 2. 


## 1.3 - Asymptotic behavior of the MLE

### 1.3.1 - LLN-type result

```{r LLN Tmax,eval=FALSE}
lambda = 2
Tillustr = 1:500
mles = c()

for (Tmax in Tillustr) {
  mles = c(mles, MLE1(simulPPh1(lambda, Tmax),Tmax))
}
plot(Tillustr,mles,xlab="Tmax",ylab="MLE")
```

Comment: Plus on a d'observations, mieux on converge vers lambda = 2. 


### 1.3.2 - CLT-type result

```{r CLT Tmax,eval=FALSE}
lambda = 2
Tillustr = c(1,10,100,500) # possible values of Tmax
K = 1000 # number of simulations of Z for each value of Tmax
Z = rep(0,K)

for (Tmax in Tillustr) {
  for (k in 1:K) {
  pph = simulPPh1(lambda,Tmax)
  mle = MLE1(pph,Tmax)
  Z[k]= sqrt(Tmax)*(mle-lambda)
}
  hist(Z,freq=FALSE,main=paste("Tmax",Tmax,sep="="))
curve(dnorm(x,mean=0,sd=sqrt(lambda)),
col="red",add=TRUE)
plot(ecdf(Z),main=paste("Tmax",Tmax,sep="="))
curve(pnorm(x,mean=0,sd=sqrt(lambda)),
col="red",lwd=2,add=TRUE)

  
}

```

Comment: Plus Tmax est grand, plus on converge vers une loi normale centrée en lambda = 2.

## 1.4 - Statistical inference: hyptothesis testing

The `test1` function returns the $p$-value of the test of $\mathcal{H}_0 : \lambda=$ `lambda0` againts $\mathcal{H}_1 : \lambda\neq$ `lambda0` given the observation of a homogeneous Poisson process `PPh` on [0,`Tmax`].

```{r test1,eval=FALSE}
test1 <- function(PPh,Tmax,lambda0)
{
  lambda_hat = MLE1(PPh, Tmax)
  T_obs = sqrt(Tmax/lambda0) * (lambda_hat - lambda0)
  
  p_value = 2 * (1- pnorm(abs(T_obs)))
    
  return(p_value)
}


```

```{r plot.level.power1}
# Plot confidence intervals for the proportion of times alpha-level tests rejects the 
# null hypothesis "lambda=lambda0" under each true distribution lambda in TrueLambda
plot.level.power1 <- function(Tmax,lambda0,TrueLambda,alpha,nsimu)
{
  plot(range(TrueLambda),c(alpha,alpha),ylim=c(0,1),xlab="True lambda",ylab="Level/Power",
       type="l",col="red",main=paste("lambda0 = ",lambda0,",  Tmax = ",Tmax,sep=""))
  abline(1,0,lty=2,col="blue")
  
  for(lambda in TrueLambda)
  {
    # estimating the proportion under lambda in TrueLambda
    propReject=0
    for(sim in 1:nsimu){
      propReject=propReject+(test1(simulPPh1(lambda,Tmax),Tmax,lambda0) <= alpha)/nsimu
    }
  # plot the confidence intervals
  points(lambda,propReject)
  points(lambda,propReject+sqrt(abs(propReject*(1-propReject))/nsimu)*qnorm(0.975),pch=2)
  points(lambda,propReject-sqrt(abs(propReject*(1-propReject))/nsimu)*qnorm(0.975),pch=6)  
  }
}
```

```{r,eval=FALSE}
# Application on an example:
alpha=0.05
nsimu=1000
lambda0=2
TrueLambda=c(1,1.5,1.8,1.9,2,2.1,2.2,2.5,3)

par(mfrow=c(1,2))
for(Tmax in c(1,10,100,500))
{
  plot.level.power1(Tmax,lambda0,TrueLambda,alpha,nsimu)
}
```

Comments: Proportion de rejet des deux tests (avec/sans Slutsky). 

# 2 - Inhomogeneous Poisson processes

Simulation of an inhomogeneous Poisson processes with given intensity function `lambda_fct` on a fixed window [0,`Tmax`]. 
```{r simulPPi,eval=FALSE}
simulPPi = function(lambda_fct,Tmax,M)
{
  hpp = simulPPh1(M, Tmax)
  unif = runif(length(hpp), 0, M)
  t = c()
  
  for (i in 1:length(hpp)){
    if (unif[i]<=lambda_fct(hpp[i])) {
      t = c(t, hpp[i])
    }
  }
  return(sort(t))
}
```

Application to $\lambda_1: x \mapsto 2x.$
```{r lambda1,eval=FALSE}
Tmax=10
lambda_fct1 <- function(x){return(2*x)}
M1=20
PPi1 = simulPPi(lambda_fct1,Tmax,M1)

# plot:
par(mfrow=c(1,2))
curve(lambda_fct1,from=0,to=Tmax,n=1000)
plot.PP(PPi1)
```
Fluctue lambda majuscule : t² fluctue autour de 105
Application to $\lambda_2: x \mapsto \frac{3}{10}x^2.$ 
```{r lambda2,eval=FALSE}
Tmax=10
lambda_fct2 <- function(x){return(3/10*x^2)}
M2= 30
PPi2 = simulPPi(lambda_fct2,Tmax,M2)

# plot:
par(mfrow=c(1,2))
curve(lambda_fct2,from=0,to=Tmax,n=1000)
plot.PP(PPi2)
```

Application to $\lambda_3: x \mapsto 100xe^{-x}.$
```{r lambda3,eval=FALSE}
Tmax=10
lambda_fct3 <- function(x){return(100*x*exp(-x))}
M3=100*exp(-1)
PPi3 = simulPPi(lambda_fct3,Tmax,M3)

# plot:
par(mfrow=c(1,2))
curve(lambda_fct3,from=0,to=Tmax,n=1000);abline(v=1,lty=2)
plot.PP(PPi3)
```
plus resseré là où l'intensité est grande 
plus de points là où l'intensité est plus grande
Application to $\lambda_4: x \mapsto 10\times 1_{[0,7]}(x) + 15\times 1_{]8,10]}(x).$
```{r lambda4,eval=FALSE}
Tmax=10
lambda_fct4 <- function(x){return(10 * as.numeric(x >= 0 & x <= 7) + 15 * as.numeric(x > 8 & x <= 10))}
M4=15
PPi4 = simulPPi(lambda_fct4,Tmax,M4)

# plot:
par(mfrow=c(1,2))
curve(lambda_fct4,from=0,to=Tmax,n=1000)
plot.PP(PPi4)
```



# 3 - Homogeneous Poisson processes with fixed number of points

Now, we consider the case of a fixed number of points (and thus a random observation window). 

## 3.1 - Simulation

Simulation of the `n` first arrival times of a homogeneous Poisson process with intensity `lambda`.
```{r simulPPh2,eval=FALSE}
simulPPh2 <- function(lambda,n)
{
  expo = rexp(n, lambda)
  return(cumsum(expo))
}
```

```{r,eval=FALSE}
# Simulation and plot of a homogeneous Poisson process:
PPh2 = simulPPh2(2,20)
plot.PP(PPh2)
```

## 3.2 - Maximum likelihood estimator
Maximum Likelihood estimator of a homogeneous Poisson process `PPh` with fixed number of points:
```{r MLE2,eval=FALSE}
MLE2 <- function(PPh)
{
  n = length(PPh)
  return(n/PPh[n])
}
```

```{r,eval=FALSE}
# Application on an example:
MLE2(PPh2)
```

Comment:

## 3.3 Asymptotic behavior of the MLE

### 3.3.1 - LLN-type result

```{r LLN n,eval=FALSE}
lambda = 2
n_list = 1:500
mles = c()

for (n in n_list) {
  mles = c(mles, MLE2(simulPPh2(lambda, n)))
}
plot(n_list,mles,xlab="n",ylab="MLE")

```

Comment: 

### 3.3.2 - CLT-type result

```{r CLT n,eval=FALSE}
lambda = 2
n_list = c(1,10,100,500) # possible values of Tmax
K = 1000 # number of simulations of Z for each value of Tmax
Z = rep(0,K)

for (n in n_list) {
  for (k in 1:K) {
  pph = simulPPh2(lambda,n)
  mle = MLE2(pph)
  Z[k]= sqrt(n)*(mle-lambda)
}
  hist(Z,freq=FALSE,main=paste("n",n,sep="="))
curve(dnorm(x,mean=0,sd=lambda),
col="red",add=TRUE)
plot(ecdf(Z),main=paste("n",n,sep="="))
curve(pnorm(x,mean=0,sd=lambda),
col="red",lwd=2,add=TRUE)

  
}
```

Comment:

## 3.4 - Statistical inference : confidence intervals

Confidence interval for the unkown intensity of a homogeneous Poisson process `PPh` with confidence level 1-`alpha` that is `asymptotic` (by default) of not. 
```{r IC2,eval=FALSE}
IC2 <- function(PPh,alpha=0.05,asymptotic=TRUE)
{
  n = length(PPh)
  Tn = PPh[n]
  if(asymptotic)
  {
    z = qnorm(1-alpha/2)
    borne_sup = n/(Tn*(1-z/sqrt(n)))
    borne_inf = n/(Tn*(1+z/sqrt(n)))
    
    return(c(borne_inf,borne_sup))
  }
  else
  {
    x1 = qchisq(alpha/2, 2*n)
    x2 = qchisq(1-alpha/2, 2*n)

    borne_inf = x1/(2*Tn)
    borne_sup =  x2/(2*Tn)
    
    return(c(borne_inf,borne_sup))
  }
}
```

```{r,eval=FALSE}
# Application on an example:
PPh2 <- simulPPh2(lambda=10,n=100)
IC = IC2(PPh2,alpha=0.05,asymptotic=TRUE)
IC_a = IC2(PPh2,alpha=0.05,asymptotic=FALSE)
```

Comment:

```{r,eval=FALSE}
# Validation on simulated data
lambda=2 ; nsimu=1000 ; n=10 # or n=100

count = 0

for (i in 1:nsimu) {
  hpp = simulPPh2(lambda, n)
  IC = IC2(hpp,alpha=0.05,asymptotic=FALSE)
  if (lambda>= IC[1] & lambda <= IC[2]) {
    count = count + 1
  }
}

print(count/nsimu)

```

```{r,eval=FALSE}
# Validation on simulated data
lambda=2 ; nsimu=1000 ; n=100 # or n=100

count = 0

for (i in 1:nsimu) {
  hpp = simulPPh2(lambda, n)
  IC = IC2(hpp,alpha=0.05,asymptotic=TRUE)
  if (lambda>= IC[1] & lambda <= IC[2]) {
    count = count + 1
  }
}

print(count/nsimu)

```

Comment:



