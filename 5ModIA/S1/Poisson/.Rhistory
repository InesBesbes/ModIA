outlier<-res.outlier$outlier
datawithout<-data[-c(outlier),]
cleanpolluant = log(datawithout[, col_polluant])
cleandata = cbind(datawithout[1:3], cleanpolluant, datawithout[15:36])
cleanACP <- data.frame(cleanpolluant, cleandata$annee_inv, cleandata$TypeEPCI)
res.acp2 <- PCA(cleanACP, quali.sup = c(12, 13), graph=FALSE)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=13)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=12)
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
Velibdata<-velib$data[,-c(1:13)]
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(funFEM)
library(reshape2)
library(ggplot2)
library(gridExtra)
library(FactoMineR)
library(factoextra)
library(corrplot)
library(mclust)
library(stringr)
library(cluster)
library(clusterSim)
library(leaflet)
library(funFEM)
data(velib)
Velibdata<-velib$data[,-c(1:13)]
colnames(Velibdata)<-velib$dates[-c(1:13)]
Velibdata
Velibdata<-velib$data[,-c(1:13)]
colnames(Velibdata)<-velib$dates[-c(1:13)]
velib$position
data = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
#summary(data)
which(colnames(data) == "long")
#summary(data)
which(colnames(data) == "longit")
#summary(data)
which(colnames(data) == "latit
")
#summary(data)
which(colnames(data) == "lati")
#summary(data)
which(colnames(data) == "latitu")
#summary(data)
which(colnames(data) == "latitude")
#summary(data)
which(colnames(data) == "lat")
#summary(data)
which(colnames(data) == "lati")
#summary(data)
which(colnames(data) == "lati")
#summary(data)
which(colnames(data) == "la")
#summary(data)
which(colnames(data) == "latit")
knitr::opts_chunk$set(echo = TRUE)
library(FactoMineR)
library(mt)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(mclust)
library(clusterSim)
#library(leaflet.providers) #remplace ggmap
library(leaps)
library(bestglm)
library(MASS)
library(factoextra)
library(circlize)
library(viridis)
set.seed(1234) #figer l'aléa pour les méthodes comme kmeans
#Bloc qui est compilé mais pas affiché
data = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
data$lib_epci = as.factor(data$lib_epci)
data$TypeEPCI = as.factor(data$TypeEPCI)
data$nomdepart = as.factor(data$nomdepart)
data$annee_inv = as.factor(data$annee_inv)
g1 <- ggplot(data, aes(x = TypeEPCI)) + geom_bar() + ylab("") + ggtitle("Effectifs")
quan <- as.vector(table(data$TypeEPCI))/nrow(data)
df <- data.frame(group = levels(data$TypeEPCI), TypeEPCI = quan)
g2 <- ggplot(df, aes(x = "", y = TypeEPCI, fill = group)) + geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) + theme(legend.position = "bottom")
grid.arrange(g2,g1, ncol = 2)
#objectif : afficher les 2 boxplots cote à cote
col_polluant = 4:14
polluant = log(data[, col_polluant])
boxplot(data[,col_polluant])
boxplot(polluant)
#Tentative d'afficher les 2 boxplots côte à côte
#g1 = ggplot(na.omit(data), aes(x = data[,col_polluant])) + geom_boxplot()
#g2 = ggplot(data, aes(x = log(data[,col_polluant]))) + geom_boxplot()
#grid.arrange(g1,g2,ncol = 2)
#hist(data[, 4], main = paste("Histogramme de" , "Nox"), xlab = "Quantité de Nox (en Kg)", ylab = "Fréquence")
#hist(polluant[, 1], main = paste("Histogramme de" , "Nox"), xlab = "Quantité de Nox (en Kg) en échelle log", ylab = "Fréquence")
g1 <- ggplot(data, aes(x =data[,4])) + xlab ("Nox")+ ylab("Effectif") + labs(title = 'Distribution de Nox') + geom_histogram(bins = 39)
g2 <- ggplot(polluant, aes(x =log(polluant[,1]))) + xlab ("Nox")+ ylab("Effectif") + labs(title = 'Distribution de log(Nox)') +  geom_histogram(bins = 39)
grid.arrange(g1,g2,ncol = 2)
corrplot(cor(polluant), method="ellipse", tl.cex = 0.7)
ggplot(polluant, aes(x = ges_teqco2, y = co2_t)) + geom_point() + geom_smooth(method = lm, se = FALSE)+ theme_minimal()
g3 <- ggplot(data, aes(x = TypeEPCI, y = log(polluant[,1]))) + ylab("log(nox_kg)") + geom_boxplot()
g4 <- ggplot(data, aes(x = annee_inv, y = log(polluant[,1]))) + ylab("log(nox_kg)") + geom_boxplot()
grid.arrange(g3,g4, ncol = 2)
res.acp<- PCA(polluant, scale.unit= FALSE)
barplot(res.acp$eig[1:5, "percentage of variance"], main="Pourcentages d'inerties")
boxplot(res.acp$ind$coord)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp2 <- PCA(dataACP, quali.sup = c(12, 13), graph=FALSE)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=13)
plot(res.acp2, axes = c(1,2), choix = "var", cex= 0.5)
#plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=12)
res.outlier <- pca.outlier(polluant)
res.outlier$plot
outlier<-res.outlier$outlier
cleandata<-data[-c(outlier),]
cleanpolluant = log(cleandata[, col_polluant])
cleanACP <- data.frame(cleanpolluant, cleandata$annee_inv, cleandata$TypeEPCI)
res.acp2 <- PCA(cleanACP, quali.sup = c(12, 13), graph=FALSE)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=13)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=12)
#methode kmeans (peut-être à mettre après)
#test des kmeans pour une valeur quelconque
reskmeans<-kmeans(log(cleandata[, col_polluant]),5)
fviz_cluster(reskmeans,log(cleandata[, col_polluant]), geom = c('point')) #clustering sur les coordonnées de l'acp plus tard?
#méthode d'inertie intra
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(cleanpolluant),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(cleanpolluant,k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
#critère silhouette
Silhou<-NULL
for (k in 2:Kmax){
aux<-silhouette(reskmeanscl[,k-1], daisy(cleanpolluant))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
#méthode d'inertie intra sur coord acp
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(res.acp2$ind$coord),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(res.acp2$ind$coord,k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
#critère silhouette sur les coordonnées de l'acp
Silhou<-NULL
for (k in 2:Kmax){
aux<-silhouette(reskmeanscl[,k-1], daisy(res.acp2$ind$coord))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
#pour comparer différent clustering on peut tracer la table de contingence, si on a le même nombre de classe on peut faire RandIndex sinon adjustedRandIndex puis interpréter
# utiliser les critères silhouette ou autres (inertie intra classe) pour trouver la meilleure valeur de K (done)
#utiliser leaflet pour visualiser sur une carte
#tracer boxplot des polluants par classe pour voir si clustering par certaines variables plus que d'autres (boxplot(resacp$ind$coord)?)
#clustering obtenu sur données initiales ou sur acp est il le meme ?
#représenter acp avec habillage selon les classifications obtenues (faire avec le clustering final pour économiser de la place?)
#voir clustering qui se ressemblent pr converger vers une classification il faut donc comparer les clustering entre eux (attention page limitées donc faire le bon choix)
#Avec intéraction
mod1inter <- lm(ges_teqco2~TypeEPCI*annee_inv, data=cleandata)
summary(mod1inter)
#Sans intéraction
mod1 <- lm(ges_teqco2~TypeEPCI + annee_inv, data=cleandata)
summary(mod1)
anova(mod1, mod1inter)
mod11 <- lm(ges_teqco2~TypeEPCI, data=cleandata)
summary(mod11)
anova(mod11, mod1)
mod12 <- lm(ges_teqco2~annee_inv, data=cleandata)
summary(mod12)
anova(mod12, mod1)
mod1intercept <- lm(ges_teqco2~1, data=cleandata)
summary(mod1intercept)
anova(mod1intercept, mod1)
anova(mod11, mod1inter)
stepAIC(mod1inter, direction=c("backward"), trace=T, k=log(nrow(cleandata)))
par(mfrow=c(1,2))
interaction.plot(cleandata[,"TypeEPCI"],cleandata[,"annee_inv"],
cleandata[,"ges_teqco2"],col=c(2,4),pch=c(18,24), main="Interaction plot",type="b",
xlab="TypeEPCI",ylab="ges_teqco2",trace.label="annee_inv")
interaction.plot(cleandata[,"annee_inv"],cleandata[,"TypeEPCI"],
cleandata[,"ges_teqco2"],col=c(2,4),pch=c(18,24), main="Interaction plot",type="b",
xlab="annee_inv",ylab="ges_teqco2",trace.label="TypeEPCI")
# avec interaction
gespolluant <- lm(ges_teqco2 ~ .^2, data = polluant)
bestmodel = step(gespolluant,direction = "forward", trace = F)
bestmodel2 = step(gespolluant, direction="backward",k=log(nrow(polluant)),trace = F)
#library(bestglm)
#bestglm(polluant,IC="AIC")
#bestglm(polluant,IC="BIC")
bestmodelstep = lm(ges_teqco2 ~ nox_kg + so2_kg + pm10_kg + pm25_kg + co_kg + c6h6_kg +
nh3_kg + ch4_t + co2_t + n2o_t ,data = polluant)
data_trans = cbind(data[1:3], polluant, data[15:36])
acpolluant<-lm(ch4_t ~ .^2, data = data_trans[c(3, 10, 12, 14, 15)])
summary(acpolluant)
stepAIC(acpolluant,trace=F,direction="backward")
stepAIC(acpolluant,trace=F,direction="backward",k=log(nrow(data_trans)))
ggplot(data_trans,aes(x=nh3_kg,y=ch4_t, shape=annee_inv))+
geom_point()+
geom_smooth(method='lm',se=T)
stepAIC(acpolluant,trace=F,direction="backward")
stepAIC(acpolluant,trace=F,direction="backward",k=log(nrow(data_trans)))
cleandata<-data[-c(outlier),]
cleanpolluant = log(cleandata[, col_polluant]) # à garder car on le modifie en suite
new_data = cleandata
cleanpolluant$ch4_t = as.factor((cleanpolluant$ch4_t > log(1000)))
new_data[, col_polluant] = cleanpolluant
MLG_data = new_data[,colnames(new_data)%in% c("ch4_t","nh3_kg","n2o_t","TypeEPCI","annee_inv")]
head(MLG_data)
# 1 == True, 0 == False
summary(MLG_data)
#modeldepassement <- glm(ch4_t ~ nh3_kg + n2o_t + TypeEPCI + annee_inv, data = MLG_data, family = binomial("logit"))
modeldepassement <- glm(ch4_t ~ .^2 , data = MLG_data, family = binomial("logit"))
summary(modeldepassement)
# ne fonctionne pas
#bestglm(MLG_data,IC = "BIC")
#bestglm(MLG_data,IC="AIC")
str(MLG_data) # réunir les type d'epci (c'est pas bon ici)
step.backward = stepAIC(modeldepassement)
bestmodel = stepAIC(modeldepassement, trace = F)
bestmodel2 = stepAIC(modeldepassement, direction="backward",k=log(nrow(polluant)),trace = F)
# message d'erreur, il n'y a pas d'affichage de résultat si on garde la trace
newcleandata = cleandata %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CC", "CC")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CA", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CU", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "Metropole", "CA"))
newcleandata$TypeEPCI = as.factor(newcleandata$TypeEPCI)
summary(newcleandata)
newcleandata = cleandata %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CC", "CC")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CA", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CU", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "Metropole", "CA"))
newcleandata$TypeEPCI = as.factor(newcleandata$TypeEPCI)
# summary(newcleandata)
?mindist   # minimal distance in DoE
??mindist   # minimal distance in DoE
rm(list = ls())
graphics.off()
library(randtoolbox)
library(DiceDesign)
help(package = "DiceDesign")
??mindist   # minimal distance in DoE
knitr::opts_chunk$set(echo = TRUE)
simulPPh1 <- function(lambda,Tmax)
{
N_tmax = rpois(1, lambda*Tmax)
unif = sort(runif(N_tmax, 0, Tmax))
return(unif)
}
setwd("~/Documents/5ModIA/Poisson")
knitr::opts_chunk$set(echo = TRUE)
simulPPh1 <- function(lambda,Tmax)
{
N_tmax = rpois(1, lambda*Tmax)
unif = sort(runif(N_tmax, 0, Tmax))
return(unif)
}
plot.PP<- function(PP)
{
# plot the counting process (with jumps of size 1 (starting at point (0,0))):
plot(c(0,PP),0:length(PP),type="s",xlab="time t",ylab="number of events by time t")
# add the arrival times on the horizontal axis:
points(PP,0*PP,type="p",pch=16)
# link arrival times with the counts:
lines(PP,0:(length(PP)-1),type="h",lty=2)
}
# Simulation and plot of a homogeneous Poisson process:
PPh1 = simulPPh1(2,100)
plot.PP(PPh1)
lambda_fct_Weibull <- function(x){
return((b/a)*(x/a)**(b-1))
}
simulPPi = function(Tmax,M)
{
hpp = simulPPh1(M, Tmax)
unif = runif(length(hpp), 0, M)
t = c()
for (i in 1:length(hpp)){
if (unif[i]<=lambda_fct_Weibull(hpp[i])) {
t = c(t, hpp[i])
}
}
return(sort(t))
}
simulPPi <- function(Tmax, M) {
hpp = simulPPh1(M, Tmax)
unif = runif(length(hpp), 0, M)
selected = (unif <= lambda_fct_Weibull(hpp))
return(sort(hpp[selected]))
}
simulPPi <- function(Tmax, M) {
hpp = simulPPh1(M, Tmax)
unif = runif(length(hpp), 0, M)
selected = (unif <= lambda_fct_Weibull(hpp))
return(sort(hpp[selected]))
}
knitr::opts_chunk$set(echo = TRUE)
lambda_fct_Weibull <- function(x){
return((b/a)*(x/a)**(b-1))
}
simulPPh1 <- function(lambda,Tmax)
{
N_tmax = rpois(1, lambda*Tmax)
unif = sort(runif(N_tmax, 0, Tmax))
return(unif)
}
plot.PP<- function(PP)
{
# plot the counting process (with jumps of size 1 (starting at point (0,0))):
plot(c(0,PP),0:length(PP),type="s",xlab="time t",ylab="number of events by time t")
# add the arrival times on the horizontal axis:
points(PP,0*PP,type="p",pch=16)
# link arrival times with the counts:
lines(PP,0:(length(PP)-1),type="h",lty=2)
}
# Simulation and plot of a homogeneous Poisson process:
PPh1 = simulPPh1(2,100)
plot.PP(PPh1)
simulPPi <- function(Tmax, M) {
hpp = simulPPh1(M, Tmax)
unif = runif(length(hpp), 0, M)
selected = (unif <= lambda_fct_Weibull(hpp))
return(sort(hpp[selected]))
}
Tmax=30
b=2.5
a=1
M = (b/a)*(Tmax/a)**(b-1)
PPi1 = simulPPi(Tmax,M1)
Tmax=30
b=2.5
a=1
M = (b/a)*(Tmax/a)**(b-1)
PPi1 = simulPPi(Tmax,M)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull,from=0,to=Tmax,n=1000)
plot.PP(PPi1)
Tmax=30
b=1
a=1
M = 0
PPi1 = simulPPi(Tmax,M)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull,from=0,to=Tmax,n=1000)
plot.PP(PPi1)
Tmax=30
b=1
a=1
M = 0
PPi2= simulPPi(Tmax,M)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull,from=0,to=Tmax,n=1000)
plot.PP(PPi2)
Tmax=10000000
b=1
a=1
M = 0
PPi2= simulPPi(Tmax,M)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull,from=0,to=Tmax,n=1000)
plot.PP(PPi2)
Tmax=30
b=1
a=1
M = 10000
PPi2= simulPPi(Tmax,M)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull,from=0,to=Tmax,n=1000)
plot.PP(PPi2)
Tmax=30
b=0.5
a=1
M = 10000
PPi2= simulPPi(Tmax,M)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull,from=0,to=Tmax,n=1000)
plot.PP(PPi2)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
lambda_fct_Weibull <- function(x, a, b){
return((b/a)*(x/a)**(b-1))
}
plot.PP <- function(PP) {
# Create a data frame for the step plot
df <- data.frame(
time = c(0, PP),
count = 0:length(PP)
)
# Create a data frame for the points (arrival times)
points_df <- data.frame(
time = PP,
count = rep(0, length(PP))
)
# Plot using ggplot
ggplot(df, aes(x = time, y = count)) +
# Add the step line with color
geom_step(direction = "hv", color = "blue", size = 1) +
# Add points for arrival times with color
geom_point(data = points_df, aes(x = time, y = count), shape = 16, color = "red", size = 3) +
# Add dashed vertical lines connecting arrival times to the steps with color
geom_segment(data = points_df, aes(x = time, xend = time, y = count, yend = match(time, PP) - 1),
linetype = "dashed", color = "black") +
# Add labels
labs(x = "Time t", y = "Number of events by time t") +
# Use a clean theme
theme_minimal()
}
Tmax=10
b=2.5
a=1
M = (b/a)*(Tmax/a)**(b-1)
PPi = simulPPi(Tmax,M,a,b)
setwd("~/Documents/5ModIA/Poisson")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
lambda_fct_Weibull <- function(x, a, b){
return((b/a)*(x/a)**(b-1))
}
simulPPh <- function(lambda,Tmax)
{
N_tmax = rpois(1, lambda*Tmax)
unif = sort(runif(N_tmax, 0, Tmax))
return(unif)
}
plot.PP <- function(PP) {
# Create a data frame for the step plot
df <- data.frame(
time = c(0, PP),
count = 0:length(PP)
)
# Create a data frame for the points (arrival times)
points_df <- data.frame(
time = PP,
count = rep(0, length(PP))
)
# Plot using ggplot
ggplot(df, aes(x = time, y = count)) +
# Add the step line with color
geom_step(direction = "hv", color = "blue", size = 1) +
# Add points for arrival times with color
geom_point(data = points_df, aes(x = time, y = count), shape = 16, color = "red", size = 3) +
# Add dashed vertical lines connecting arrival times to the steps with color
geom_segment(data = points_df, aes(x = time, xend = time, y = count, yend = match(time, PP) - 1),
linetype = "dashed", color = "black") +
# Add labels
labs(x = "Time t", y = "Number of events by time t") +
# Use a clean theme
theme_minimal()
}
# Simulation and plot of a homogeneous Poisson process:
PPh = simulPPh(2,100)
plot.PP(PPh)
simulPPi <- function(Tmax, M, a, b) {
hpp = simulPPh(M, Tmax)
unif = runif(length(hpp), 0, M)
selected = (unif <= lambda_fct_Weibull(hpp, a, b))
return(sort(hpp[selected]))
}
Tmax=10
b=2.5
a=1
M = (b/a)*(Tmax/a)**(b-1)
PPi = simulPPi(Tmax,M,a,b)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull(x,a,b),from=0,to=Tmax,n=1000)
plot.PP(PPi)
Tmax=1000
b=0.5
a=1
M = 10000
PPi2= simulPPi(Tmax,M,a ,b)
par(mfrow=c(1,2))
curve(lambda_fct_Weibull(x,a,b),from=0,to=Tmax,n=1000)
plot.PP(PPi2)
