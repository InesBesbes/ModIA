fviz_pca_ind(res.acp, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13, addEllipses = TRUE, ellipse.level = 0.95,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp)
boxplot(res.acp$ind$coord)
res.outlier <- pca.outlier(polluant)
res.outlier$plot
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13, addEllipses = TRUE, ellipse.level = 0.95,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp)
boxplot(res.acp$ind$coord)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13, addEllipses = TRUE, ellipse.level = 0.95,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp)
boxplot(res.acp$ind$coord)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp.new <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp.new, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13, addEllipses = TRUE, ellipse.level = 0.95,
legend.title = "Type EPCI")
fviz_pca_var(res.acp.new, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp.new)
boxplot(res.acp.new$ind$coord)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp.new <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2))
fviz_pca_ind(res.acp.new, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13, addEllipses = TRUE, ellipse.level = 0.95,
legend.title = "Type EPCI")
fviz_pca_var(res.acp.new, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp.new)
boxplot(res.acp.new$ind$coord)
library(FactoMineR)
library(mt)
library(ggplot2)
library(gridExtra)
library(corrplot)
#library(leaflet.providers) #remplace ggmap
library(leaps)
library(bestglm)
library(MASS)
library(factoextra)
library(glmnet)
library(plotly)
library(coefplot)
set.seed(1234) #figer l'aléa pour les méthodes comme kmeans
data = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
#summary(data)
df <- data.frame(group = levels(data$TypeEPCI), TypeEPCI = quan)
data$lib_epci = as.factor(data$lib_epci)
data$TypeEPCI = as.factor(data$TypeEPCI)
data$nomdepart = as.factor(data$nomdepart)
data$annee_inv = as.factor(data$annee_inv)
df <- data.frame(group = levels(data$TypeEPCI), TypeEPCI = quan)
quan = as.vector(table(data$TypeEPCI))/nrow(data)
df <- data.frame(group = levels(data$TypeEPCI), TypeEPCI = quan)
ggplot(df, aes(x = "", y = TypeEPCI, fill = group)) + geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) + theme(legend.position = "bottom")
#objectif : afficher les 2 boxplots cote à cote
col_polluant = 4:14
polluant = log(data[, col_polluant])
boxplot(data[,col_polluant])
boxplot(polluant)
g1 <- ggplot(data, aes(x =data[,4])) + ylab("Effectif") + labs(title = 'Distribution de Nox') + geom_histogram(bins = 39)
g2 <- ggplot(polluant, aes(x =log(polluant[,1]))) + ylab("Effectif") + labs(title = 'Distribution de log(Nox)') +  geom_histogram(bins = 39)
grid.arrange(g1,g2,ncol = 2, bottom = NULL)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp.new <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp.new, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13, addEllipses = TRUE, ellipse.level = 0.95,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp.new <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp.new, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp)
boxplot(res.acp$ind$coord)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp <- PCA(dataACP, quali.sup = c(12, 13) ,graph = FALSE, axes = c(1,2), scale.unit = TRUE)
fviz_pca_ind(res.acp, axes=c(1,2),  geom = c("point"),  repel = FALSE, habillage = 13,
legend.title = "Type EPCI")
fviz_pca_var(res.acp, axes = c(1, 2), geom = c("arrow", "text"))
# fviz_pca_biplot(res.acp, axes = c(1, 2), geom = c("point"),  geom.var = c("arrow", "text"), habillage = 13)
fviz_eig(res.acp)
boxplot(res.acp$ind$coord)
outlier<-res.outlier$outlier
res.outlier <- pca.outlier(polluant)
res.outlier$plot
outlier<-res.outlier$outlier
datawithout<-data[-c(outlier),]
cleanpolluant = log(datawithout[, col_polluant])
cleandata = cbind(datawithout[1:3], cleanpolluant, datawithout[15:36])
cleanACP <- data.frame(cleanpolluant, cleandata$annee_inv, cleandata$TypeEPCI)
res.acp2 <- PCA(cleanACP, quali.sup = c(12, 13), graph=FALSE)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=13)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=12)
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
Velibdata<-velib$data[,-c(1:13)]
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(funFEM)
library(reshape2)
library(ggplot2)
library(gridExtra)
library(FactoMineR)
library(factoextra)
library(corrplot)
library(mclust)
library(stringr)
library(cluster)
library(clusterSim)
library(leaflet)
library(funFEM)
data(velib)
Velibdata<-velib$data[,-c(1:13)]
colnames(Velibdata)<-velib$dates[-c(1:13)]
Velibdata
Velibdata<-velib$data[,-c(1:13)]
colnames(Velibdata)<-velib$dates[-c(1:13)]
velib$position
data = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
#summary(data)
which(colnames(data) == "long")
#summary(data)
which(colnames(data) == "longit")
#summary(data)
which(colnames(data) == "latit
")
#summary(data)
which(colnames(data) == "lati")
#summary(data)
which(colnames(data) == "latitu")
#summary(data)
which(colnames(data) == "latitude")
#summary(data)
which(colnames(data) == "lat")
#summary(data)
which(colnames(data) == "lati")
#summary(data)
which(colnames(data) == "lati")
#summary(data)
which(colnames(data) == "la")
#summary(data)
which(colnames(data) == "latit")
knitr::opts_chunk$set(echo = TRUE)
library(FactoMineR)
library(mt)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(mclust)
library(clusterSim)
#library(leaflet.providers) #remplace ggmap
library(leaps)
library(bestglm)
library(MASS)
library(factoextra)
library(circlize)
library(viridis)
set.seed(1234) #figer l'aléa pour les méthodes comme kmeans
#Bloc qui est compilé mais pas affiché
data = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
data$lib_epci = as.factor(data$lib_epci)
data$TypeEPCI = as.factor(data$TypeEPCI)
data$nomdepart = as.factor(data$nomdepart)
data$annee_inv = as.factor(data$annee_inv)
g1 <- ggplot(data, aes(x = TypeEPCI)) + geom_bar() + ylab("") + ggtitle("Effectifs")
quan <- as.vector(table(data$TypeEPCI))/nrow(data)
df <- data.frame(group = levels(data$TypeEPCI), TypeEPCI = quan)
g2 <- ggplot(df, aes(x = "", y = TypeEPCI, fill = group)) + geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) + theme(legend.position = "bottom")
grid.arrange(g2,g1, ncol = 2)
#objectif : afficher les 2 boxplots cote à cote
col_polluant = 4:14
polluant = log(data[, col_polluant])
boxplot(data[,col_polluant])
boxplot(polluant)
#Tentative d'afficher les 2 boxplots côte à côte
#g1 = ggplot(na.omit(data), aes(x = data[,col_polluant])) + geom_boxplot()
#g2 = ggplot(data, aes(x = log(data[,col_polluant]))) + geom_boxplot()
#grid.arrange(g1,g2,ncol = 2)
#hist(data[, 4], main = paste("Histogramme de" , "Nox"), xlab = "Quantité de Nox (en Kg)", ylab = "Fréquence")
#hist(polluant[, 1], main = paste("Histogramme de" , "Nox"), xlab = "Quantité de Nox (en Kg) en échelle log", ylab = "Fréquence")
g1 <- ggplot(data, aes(x =data[,4])) + xlab ("Nox")+ ylab("Effectif") + labs(title = 'Distribution de Nox') + geom_histogram(bins = 39)
g2 <- ggplot(polluant, aes(x =log(polluant[,1]))) + xlab ("Nox")+ ylab("Effectif") + labs(title = 'Distribution de log(Nox)') +  geom_histogram(bins = 39)
grid.arrange(g1,g2,ncol = 2)
corrplot(cor(polluant), method="ellipse", tl.cex = 0.7)
ggplot(polluant, aes(x = ges_teqco2, y = co2_t)) + geom_point() + geom_smooth(method = lm, se = FALSE)+ theme_minimal()
g3 <- ggplot(data, aes(x = TypeEPCI, y = log(polluant[,1]))) + ylab("log(nox_kg)") + geom_boxplot()
g4 <- ggplot(data, aes(x = annee_inv, y = log(polluant[,1]))) + ylab("log(nox_kg)") + geom_boxplot()
grid.arrange(g3,g4, ncol = 2)
res.acp<- PCA(polluant, scale.unit= FALSE)
barplot(res.acp$eig[1:5, "percentage of variance"], main="Pourcentages d'inerties")
boxplot(res.acp$ind$coord)
dataACP <- data.frame(polluant, data$annee_inv, data$TypeEPCI)
res.acp2 <- PCA(dataACP, quali.sup = c(12, 13), graph=FALSE)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=13)
plot(res.acp2, axes = c(1,2), choix = "var", cex= 0.5)
#plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=12)
res.outlier <- pca.outlier(polluant)
res.outlier$plot
outlier<-res.outlier$outlier
cleandata<-data[-c(outlier),]
cleanpolluant = log(cleandata[, col_polluant])
cleanACP <- data.frame(cleanpolluant, cleandata$annee_inv, cleandata$TypeEPCI)
res.acp2 <- PCA(cleanACP, quali.sup = c(12, 13), graph=FALSE)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=13)
plot(res.acp2, axes = c(1,2), choix = "ind", cex= 0.5, label = "quali", habillage=12)
#methode kmeans (peut-être à mettre après)
#test des kmeans pour une valeur quelconque
reskmeans<-kmeans(log(cleandata[, col_polluant]),5)
fviz_cluster(reskmeans,log(cleandata[, col_polluant]), geom = c('point')) #clustering sur les coordonnées de l'acp plus tard?
#méthode d'inertie intra
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(cleanpolluant),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(cleanpolluant,k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
#critère silhouette
Silhou<-NULL
for (k in 2:Kmax){
aux<-silhouette(reskmeanscl[,k-1], daisy(cleanpolluant))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
#méthode d'inertie intra sur coord acp
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(res.acp2$ind$coord),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(res.acp2$ind$coord,k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
#critère silhouette sur les coordonnées de l'acp
Silhou<-NULL
for (k in 2:Kmax){
aux<-silhouette(reskmeanscl[,k-1], daisy(res.acp2$ind$coord))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
#pour comparer différent clustering on peut tracer la table de contingence, si on a le même nombre de classe on peut faire RandIndex sinon adjustedRandIndex puis interpréter
# utiliser les critères silhouette ou autres (inertie intra classe) pour trouver la meilleure valeur de K (done)
#utiliser leaflet pour visualiser sur une carte
#tracer boxplot des polluants par classe pour voir si clustering par certaines variables plus que d'autres (boxplot(resacp$ind$coord)?)
#clustering obtenu sur données initiales ou sur acp est il le meme ?
#représenter acp avec habillage selon les classifications obtenues (faire avec le clustering final pour économiser de la place?)
#voir clustering qui se ressemblent pr converger vers une classification il faut donc comparer les clustering entre eux (attention page limitées donc faire le bon choix)
#Avec intéraction
mod1inter <- lm(ges_teqco2~TypeEPCI*annee_inv, data=cleandata)
summary(mod1inter)
#Sans intéraction
mod1 <- lm(ges_teqco2~TypeEPCI + annee_inv, data=cleandata)
summary(mod1)
anova(mod1, mod1inter)
mod11 <- lm(ges_teqco2~TypeEPCI, data=cleandata)
summary(mod11)
anova(mod11, mod1)
mod12 <- lm(ges_teqco2~annee_inv, data=cleandata)
summary(mod12)
anova(mod12, mod1)
mod1intercept <- lm(ges_teqco2~1, data=cleandata)
summary(mod1intercept)
anova(mod1intercept, mod1)
anova(mod11, mod1inter)
stepAIC(mod1inter, direction=c("backward"), trace=T, k=log(nrow(cleandata)))
par(mfrow=c(1,2))
interaction.plot(cleandata[,"TypeEPCI"],cleandata[,"annee_inv"],
cleandata[,"ges_teqco2"],col=c(2,4),pch=c(18,24), main="Interaction plot",type="b",
xlab="TypeEPCI",ylab="ges_teqco2",trace.label="annee_inv")
interaction.plot(cleandata[,"annee_inv"],cleandata[,"TypeEPCI"],
cleandata[,"ges_teqco2"],col=c(2,4),pch=c(18,24), main="Interaction plot",type="b",
xlab="annee_inv",ylab="ges_teqco2",trace.label="TypeEPCI")
# avec interaction
gespolluant <- lm(ges_teqco2 ~ .^2, data = polluant)
bestmodel = step(gespolluant,direction = "forward", trace = F)
bestmodel2 = step(gespolluant, direction="backward",k=log(nrow(polluant)),trace = F)
#library(bestglm)
#bestglm(polluant,IC="AIC")
#bestglm(polluant,IC="BIC")
bestmodelstep = lm(ges_teqco2 ~ nox_kg + so2_kg + pm10_kg + pm25_kg + co_kg + c6h6_kg +
nh3_kg + ch4_t + co2_t + n2o_t ,data = polluant)
data_trans = cbind(data[1:3], polluant, data[15:36])
acpolluant<-lm(ch4_t ~ .^2, data = data_trans[c(3, 10, 12, 14, 15)])
summary(acpolluant)
stepAIC(acpolluant,trace=F,direction="backward")
stepAIC(acpolluant,trace=F,direction="backward",k=log(nrow(data_trans)))
ggplot(data_trans,aes(x=nh3_kg,y=ch4_t, shape=annee_inv))+
geom_point()+
geom_smooth(method='lm',se=T)
stepAIC(acpolluant,trace=F,direction="backward")
stepAIC(acpolluant,trace=F,direction="backward",k=log(nrow(data_trans)))
cleandata<-data[-c(outlier),]
cleanpolluant = log(cleandata[, col_polluant]) # à garder car on le modifie en suite
new_data = cleandata
cleanpolluant$ch4_t = as.factor((cleanpolluant$ch4_t > log(1000)))
new_data[, col_polluant] = cleanpolluant
MLG_data = new_data[,colnames(new_data)%in% c("ch4_t","nh3_kg","n2o_t","TypeEPCI","annee_inv")]
head(MLG_data)
# 1 == True, 0 == False
summary(MLG_data)
#modeldepassement <- glm(ch4_t ~ nh3_kg + n2o_t + TypeEPCI + annee_inv, data = MLG_data, family = binomial("logit"))
modeldepassement <- glm(ch4_t ~ .^2 , data = MLG_data, family = binomial("logit"))
summary(modeldepassement)
# ne fonctionne pas
#bestglm(MLG_data,IC = "BIC")
#bestglm(MLG_data,IC="AIC")
str(MLG_data) # réunir les type d'epci (c'est pas bon ici)
step.backward = stepAIC(modeldepassement)
bestmodel = stepAIC(modeldepassement, trace = F)
bestmodel2 = stepAIC(modeldepassement, direction="backward",k=log(nrow(polluant)),trace = F)
# message d'erreur, il n'y a pas d'affichage de résultat si on garde la trace
newcleandata = cleandata %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CC", "CC")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CA", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CU", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "Metropole", "CA"))
newcleandata$TypeEPCI = as.factor(newcleandata$TypeEPCI)
summary(newcleandata)
newcleandata = cleandata %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CC", "CC")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CA", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "CU", "CA")) %>%
mutate(TypeEPCI = str_replace(TypeEPCI, "Metropole", "CA"))
newcleandata$TypeEPCI = as.factor(newcleandata$TypeEPCI)
# summary(newcleandata)
rm(list = ls())
source("EGOutils.R")
setwd("~/Documents/5ModIA/Metamodeling/Lab2")
rm(list = ls())
source("EGOutils.R")
ozone <- read.table("depSeuil.dat", sep = ",", header = TRUE)
rm(list = ls())
source("EGOutils.R")
ozone <- read.table("depSeuil.dat", sep = ",", header = TRUE)
# Vérification du contenu
summary(ozone)
# Changement du type de la variable jour en facteur
ozone[, "JOUR"] <- as.factor(ozone[, "JOUR"])
par(mfrow = c(1, 2))
options(repr.plot.width = 6, repr.plot.height = 3)
hist(ozone[, "O3obs"])
hist(ozone[, "NO2"])
ozone[, "SRMH2O"] <- sqrt(ozone[, "RMH2O"])
ozone[, "LNO2"] <- log(ozone[, "NO2"])
ozone[, "LNO"] <- log(ozone[, "NO"])
ozone <- ozone[, c(1:4, 8:13)]
summary(ozone)
pairs(ozone[, c(3, 4, 6:10)])
set.seed(111) # initialisation du générateur
# Extraction des échantillons
test.ratio <- .2   # part de l'échantillon test
npop <- nrow(ozone) # nombre de lignes dans les données
nvar <- ncol(ozone) # nombre de colonnes
# taille de l'échantillon test
ntest <- ceiling(npop * test.ratio)
# indices de l'échantillon test
testi <- sample(1:npop, ntest)
# indices de l'échantillon d'apprentissage
appri <- setdiff(1:npop, testi)
# construction de l'échantillon d'apprentissage
datappr <- ozone[appri, -11]
# construction de l'échantillon test
datestr <- ozone[testi, -11]
summary(datappr) # vérification
# construction de l'échantillon d'apprentissage
datappq <- ozone[appri,-2]
# construction de l'échantillon test
datestq <- ozone[testi,-2]
summary(datappq) # vérification
library(e1071)
# SVM avec reglages par defaut
svmDEF <- svm(O3obs ~ ., data = datappr)
svmDEF
# ----------
# QUESTION 1
# ----------
# Creer une fonction cout qui calcule l'erreur par validation croisee
kFoldError <- function(param){
set.seed(0)   # pour figer les "folds" dans la validation croisee
obj <- tune.svm(O3obs ~ ., data = datappr,
gamma = param[0],
cost = param[1],
epsilon = param[2])
return(obj$best.performance)
}
parDEF <- c(svmDEF$gamma, svmDEF$cost, svmDEF$epsilon)
cat("\n(k-fold) error (default model):",
round(kFoldError(parDEF), 3),
"\nCorresponding parameter values:", round(parDEF, 2))
# ----------
# QUESTION 1
# ----------
# Creer une fonction cout qui calcule l'erreur par validation croisee
kFoldError <- function(param){
set.seed(0)   # pour figer les "folds" dans la validation croisee
obj <- tune.svm(O3obs ~ ., data = datappr,
gamma = param[1],
cost = param[2],
epsilon = param[3])
return(obj$best.performance)
}
parDEF <- c(svmDEF$gamma, svmDEF$cost, svmDEF$epsilon)
cat("\n(k-fold) error (default model):",
round(kFoldError(parDEF), 3),
"\nCorresponding parameter values:", round(parDEF, 2))
# ----------
# QUESTION 2
# ----------
# Representer la fonction cout contre chaque variable
# En deduire un domaine de recherche pour cost, gamma et epsilon
# Valeur de la fonction cout pour (costOpt, gammaOpt, epsilonOpt) ?
svmTuneCost <- tune.svm(O3obs ~ ., data = datappr,
cost = seq(from = 0.5, to = 5, length.out = 6))
# ----------
# QUESTION 1
# ----------
# Creer une fonction cout qui calcule l'erreur par validation croisee
kFoldError <- function(param){
set.seed(0)   # pour figer les "folds" dans la validation croisee
obj <- tune.svm(O3obs ~ ., data = datappr,
gamma = param[1],
cost = param[2],
epsilon = param[3])
return(obj$best.performance)
}
parDEF <- c(svmDEF$gamma, svmDEF$cost, svmDEF$epsilon)
cat("\n(k-fold) error (default model):",
round(kFoldError(parDEF), 3),
"\nCorresponding parameter values:", round(parDEF, 2))
# ----------
# QUESTION 2
# ----------
# Representer la fonction cout contre chaque variable
# En deduire un domaine de recherche pour cost, gamma et epsilon
# Valeur de la fonction cout pour (costOpt, gammaOpt, epsilonOpt) ?
svmTuneCost <- tune.svm(O3obs ~ ., data = datappr,
cost = seq(from = 0.5, to = 5, length.out = 6))
plot(svmTuneCost)
costOpt <- as.numeric(svmTuneCost$best.parameters)
plot(svmTuneCost)
svmTuneGamma <- tune.svm(O3obs ~ ., data = datappr,
gamma = seq(from = 0.05, to = 0.1, length.out = 30))
plot(svmTuneGamma)
plot(svmTuneGamma)
plot(svmTuneGamma)
svmTuneEps <- tune.svm(O3obs ~ ., data = datappr,
epsilon = seq(from = 0.1, to = 0.5, length.out = 30))
plot(svmTuneEps)
costOpt <- as.numeric(svmTuneCost$best.parameters)
gammaOpt <- as.numeric(svmTuneGamma$best.parameters)
epsilonOpt <- as.numeric(svmTuneEps$best.parameters)
parMAR <- c(gammaOpt, costOpt, epsilonOpt)
cat("\n(k-fold) error (marginal optmization):",
round(kFoldError(parMAR), 3),
"\nCorresponding parameter values:", round(parMAR, 2))
svmTuneGamma <- tune.svm(O3obs ~ ., data = datappr,
gamma = seq(from = 0.05, to = 0.1, length.out = 30))
plot(svmTuneGamma)
svmTuneEps <- tune.svm(O3obs ~ ., data = datappr,
epsilon = seq(from = 0.1, to = 0.5, length.out = 20))
plot(svmTuneEps)
View(svmTuneGamma)
