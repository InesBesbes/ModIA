cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(mclust)
library(cluster)
library(factoextra)
library(FactoMineR)
library(ppclust)
library(reticulate)
library(ggplot2)
library(reshape)
library(corrplot)
library(gridExtra)
library(circlize)
library(viridis)
library(reshape2)
library(klaR)
str(wine)
res.acp = PCA(wine[,3:8], scale.unit = TRUE, ncp = 6, quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
fviz_pca_ind(res.acp, col.ind = as.factor(reskmeans$cluster), geom=c("point"), axes = c(1,2))
reskmeans
# J indice des variables
# Data = jeu de données
# clust = clustering étudié
# output : graphe par variable dans J donnant la répartition des modalités de J par classe de clust
barplotClus <- function(clust, Data, J) {
aux.long.p <- heatm(clust, Data, J)$freq
# ux<-unique(aux.long.p$variable)
for (j in J) {
p <- ggplot(aux.long.p[which(aux.long.p$variable == colnames(Data)[j]), ],
aes(x = clust, y = perc, fill = value)) + geom_bar(stat = "identity")+
labs(fill = colnames(Data)[j])
print(p)
}
}
heatm <- function(clust, Data, J) {
library(dplyr)
Dataaux <- data.frame(id.s = c(1:nrow(Data)), Data)
aux <- cbind(Dataaux, clust)
aux.long <- melt(data.frame(lapply(aux, as.character)), stringsAsFactors = FALSE,
id = c("id.s", "clust"), factorsAsStrings = T)
# Effectifs
aux.long.q <- aux.long %>%
group_by(clust, variable, value) %>%
mutate(count = n_distinct(id.s)) %>%
distinct(clust, variable, value, count)
# avec fréquences
aux.long.p <- aux.long.q %>%
group_by(clust, variable) %>%
mutate(perc = count/sum(count)) %>%
arrange(clust)
Lev <- NULL
for (j in 1:ncol(Data)) Lev <- c(Lev, levels(Data[, j]))
Jaux <- NULL
for (j in 1:length(J)) {
Jaux <- c(Jaux, which(aux.long.p$variable == colnames(Data)[J[j]]))
}
gaux <- ggplot(aux.long.p[Jaux, ], aes(x = clust, y = value)) + geom_tile(aes(fill = perc)) +
scale_fill_gradient2(low = "white", mid = "blue", high = "red") + theme_minimal()
return(list(gaux = gaux, eff = aux.long.q, freq = aux.long.p))
}
Kmax<-15
resPAMcl<-matrix(0,nrow=nrow(wine),ncol=Kmax-1)
Silhou<-NULL
for (k in 2:Kmax){
resaux<-pam(wine_quant, k, metric = "euclidean")
resPAMcl[,k-1]<-resaux$clustering
aux<-silhouette(resPAMcl[,k-1], daisy(wine[,-c(1,2)]))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
aux<-silhouette(resPAMcl[,1], daisy(wine[,-c(1:2)]))
fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
adjustedRandIndex(aux, auxs)
wine_quant = wine[,3:8]
wine_quant = scale(wine_quant, center = T, scale = T)
resPAM<-pam(wine_quant, 3, metric = "euclidean")
resPAM$medoids
resPAM$id.med
fviz_cluster(resPAM,data=wine[,-c(1,2)],ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
fviz_pca_ind(res.acp,col.ind=as.factor(resPAM$clustering),geom = c("point"),axes=c(1,2))
adjustedRandIndex(resPAM$clustering, wine$Qualite)
adjustedRandIndex(resPAM$clustering, wine$Type)
adjustedRandIndex(resPAM$clustering, reskmeans$cluster)
table(resPAM$clustering, reskmeans$cluster)
Kmax<-15
resPAMcl<-matrix(0,nrow=nrow(wine),ncol=Kmax-1)
Silhou<-NULL
for (k in 2:Kmax){
resaux<-pam(wine[], k, metric = "euclidean")
resPAMcl[,k-1]<-resaux$clustering
aux<-silhouette(resPAMcl[,k-1], daisy(wine[,-c(1,2)]))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
aux<-silhouette(resPAMcl[,1], daisy(wine[,-c(1:2)]))
fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
adjustedRandIndex(aux, auxs)
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(mclust)
library(cluster)
library(factoextra)
library(FactoMineR)
library(ppclust)
library(reticulate)
library(ggplot2)
library(reshape)
library(corrplot)
library(gridExtra)
library(circlize)
library(viridis)
library(reshape2)
library(klaR)
str(wine)
res.acp = PCA(wine[,3:8], scale.unit = TRUE, ncp = 6, quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
fviz_pca_ind(res.acp, col.ind = as.factor(reskmeans$cluster), geom=c("point"), axes = c(1,2))
reskmeans
# J indice des variables
# Data = jeu de données
# clust = clustering étudié
# output : graphe par variable dans J donnant la répartition des modalités de J par classe de clust
barplotClus <- function(clust, Data, J) {
aux.long.p <- heatm(clust, Data, J)$freq
# ux<-unique(aux.long.p$variable)
for (j in J) {
p <- ggplot(aux.long.p[which(aux.long.p$variable == colnames(Data)[j]), ],
aes(x = clust, y = perc, fill = value)) + geom_bar(stat = "identity")+
labs(fill = colnames(Data)[j])
print(p)
}
}
heatm <- function(clust, Data, J) {
library(dplyr)
Dataaux <- data.frame(id.s = c(1:nrow(Data)), Data)
aux <- cbind(Dataaux, clust)
aux.long <- melt(data.frame(lapply(aux, as.character)), stringsAsFactors = FALSE,
id = c("id.s", "clust"), factorsAsStrings = T)
# Effectifs
aux.long.q <- aux.long %>%
group_by(clust, variable, value) %>%
mutate(count = n_distinct(id.s)) %>%
distinct(clust, variable, value, count)
# avec fréquences
aux.long.p <- aux.long.q %>%
group_by(clust, variable) %>%
mutate(perc = count/sum(count)) %>%
arrange(clust)
Lev <- NULL
for (j in 1:ncol(Data)) Lev <- c(Lev, levels(Data[, j]))
Jaux <- NULL
for (j in 1:length(J)) {
Jaux <- c(Jaux, which(aux.long.p$variable == colnames(Data)[J[j]]))
}
gaux <- ggplot(aux.long.p[Jaux, ], aes(x = clust, y = value)) + geom_tile(aes(fill = perc)) +
scale_fill_gradient2(low = "white", mid = "blue", high = "red") + theme_minimal()
return(list(gaux = gaux, eff = aux.long.q, freq = aux.long.p))
}
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(mclust)
library(cluster)
library(factoextra)
library(FactoMineR)
library(ppclust)
library(reticulate)
library(ggplot2)
library(reshape)
library(corrplot)
library(gridExtra)
library(circlize)
library(viridis)
library(reshape2)
library(klaR)
str(wine)
res.acp = PCA(wine[,3:8], scale.unit = TRUE, ncp = 6, quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
fviz_pca_ind(res.acp, col.ind = as.factor(reskmeans$cluster), geom=c("point"), axes = c(1,2))
# A completer
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(wine),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(wine_quant, centers = k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
# A COMPLETER
Silhou<-NULL
for (k in 2:Kmax){
aux<-silhouette(reskmeanscl[,k-1], daisy(wine_quant))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
aux<-silhouette(reskmeanscl[,3], daisy(wine_quant))
fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
rm(df,Silhou,aux)
resPAM<-pam(wine_quant, 3, metric = "euclidean")
resPAM$medoids
resPAM$id.med
fviz_cluster(resPAM,data=wine[,-c(1,2)],ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
fviz_pca_ind(res.acp,col.ind=as.factor(resPAM$clustering),geom = c("point"),axes=c(1,2))
adjustedRandIndex(resPAM$clustering, wine$Qualite)
adjustedRandIndex(resPAM$clustering, wine$Type)
adjustedRandIndex(resPAM$clustering, reskmeans$cluster)
table(resPAM$clustering, reskmeans$cluster)
Kmax<-15
resPAMcl<-matrix(0,nrow=nrow(wine),ncol=Kmax-1)
Silhou<-NULL
for (k in 2:Kmax){
resaux<-pam(wine_quant, k, metric = "euclidean")
resPAMcl[,k-1]<-resaux$clustering
aux<-silhouette(resPAMcl[,k-1], daisy(wine[,-c(1,2)]))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
aux<-silhouette(resPAMcl[,1], daisy(wine[,-c(1:2)]))
fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
### Présentation
Avec les algorithmes de clustering précédents (Kmeans, PAM) nous obtenons une classification "dure" au sens que chaque individu ne peut appartenir qu'à une seule classe et chaque individu participe avec le même poids à la construction des classes. Une classification dure $\mathcal{P}_K=\{\mathcal{C}_1,\ldots,\mathcal{C}_K\}$ peut se traduire en une matrice $Z=(z_{ik})_{\underset{1\leq k \leq K}{1\leq i \leq n}}$ avec $z_{ik}=1$ si $i\in\mathcal{C}_k$ et 0 sinon. Dans cette section, nous allons nous intéresser à une adaptation de l'algorithme des Kmeans, appelée *fuzzy c-means*. L'idée est de retourner une classification *fuzzy* c'est-à-dire une matrice $W=(\omega_{ik})_{\underset{1\leq k \leq K}{1\leq i \leq n}}$ avec $\forall i,\ k,\ \omega_{ik}\geq 0$ et $\forall i,\ \underset{k=1}{\stackrel{K}{\sum}} \omega_{ik}=1$. On donne ainsi plutôt un poids $\omega_{ik}$ que l'individu $i$ appartienne à la classe $\mathcal{C}_k$.
Kmax<-15
resPAMcl<-matrix(0,nrow=nrow(wine),ncol=Kmax-1)
Silhou<-NULL
for (k in 2:Kmax){
resaux<-pam(wine_quant, k, metric = "euclidean")
resPAMcl[,k-1]<-resaux$clustering
aux<-silhouette(resPAMcl[,k-1], daisy(wine_quant))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
aux<-silhouette(resPAMcl[,1], daisy(wine[,-c(1:2)]))
fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
Kmax<-15
resPAMcl<-matrix(0,nrow=nrow(wine),ncol=Kmax-1)
Silhou<-NULL
for (k in 2:Kmax){
resaux<-pam(wine_quant, k, metric = "euclidean")
resPAMcl[,k-1]<-resaux$clustering
aux<-silhouette(resPAMcl[,k-1], daisy(wine_quant))
Silhou<-c(Silhou,mean(aux[,3]))
}
df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
geom_point()+
geom_line()+theme(legend.position = "bottom")
aux<-silhouette(resPAMcl[,1], daisy(wine_quant))
fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
help(fcm)
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3)
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3, m=2)
table(apply(resfcm$u, 1, which.max))
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3, m=2)
resfcm$u
table(apply(resfcm$u, 1, which.max))
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3, m=2)
table(apply(resfcm$u, 1, which.max))
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3, m=2)
table(apply(resfcm$u, 1, which.max)) # on sélectionne le poids le plus grand
boxplot(apply(resfcm$u, 1, max))~apply(resfcm$u, 1, which.max)
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3, m=2)
table(apply(resfcm$u, 1, which.max)) # on sélectionne le poids le plus grand
boxplot(apply(resfcm$u, 1, max)~apply(resfcm$u, 1, which.max))
# A COMPLETER
library(ppclust)
resfcm<-fcm(wine_quant, 3, m=2)
table(apply(resfcm$u, 1, which.max)) # on sélectionne le poids le plus grand
boxplot(apply(resfcm$u, 1, max)~apply(resfcm$u, 1, which.max))
#on attribue l'indiidu à la classe où il a le poids le plus fort
# A COMPLETER
fviz_pca_ind(resacp,axes=c(1,2),geom=c("point"),col.ind=apply(resfcm$u, 1, which.max))+
scale_color_gradient2(low="white", mid="blue",high="red", midpoint=0.8, space = "Lab")
# A COMPLETER
fviz_pca_ind(res.acp,axes=c(1,2),geom=c("point"),col.ind=apply(resfcm$u, 1, which.max))+
scale_color_gradient2(low="white", mid="blue",high="red", midpoint=0.8, space = "Lab")
# A COMPLETER
fviz_pca_ind(res.acp,axes=c(1,2),geom=c("point"),col.ind=apply(resfcm$u, 1, max))+
scale_color_gradient2(low="white", mid="blue",high="red", midpoint=0.8, space = "Lab")
res.acp = PCA(wine, scale.unit = TRUE, ncp = 6, quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
res.acp = PCA(wine, scale.unit = TRUE, ncp = ncol(6), quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(mclust)
library(cluster)
library(factoextra)
library(FactoMineR)
library(ppclust)
library(reticulate)
library(ggplot2)
library(reshape)
library(corrplot)
library(gridExtra)
library(circlize)
library(viridis)
library(reshape2)
library(klaR)
str(wine)
res.acp = PCA(wine, scale.unit = TRUE, ncp = ncol(6), quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
fviz_pca_ind(res.acp, col.ind = as.factor(reskmeans$cluster), geom=c("point"), axes = c(1,2))
reskmeans
# J indice des variables
# Data = jeu de données
# clust = clustering étudié
# output : graphe par variable dans J donnant la répartition des modalités de J par classe de clust
barplotClus <- function(clust, Data, J) {
aux.long.p <- heatm(clust, Data, J)$freq
# ux<-unique(aux.long.p$variable)
for (j in J) {
p <- ggplot(aux.long.p[which(aux.long.p$variable == colnames(Data)[j]), ],
aes(x = clust, y = perc, fill = value)) + geom_bar(stat = "identity")+
labs(fill = colnames(Data)[j])
print(p)
}
}
heatm <- function(clust, Data, J) {
library(dplyr)
Dataaux <- data.frame(id.s = c(1:nrow(Data)), Data)
aux <- cbind(Dataaux, clust)
aux.long <- melt(data.frame(lapply(aux, as.character)), stringsAsFactors = FALSE,
id = c("id.s", "clust"), factorsAsStrings = T)
# Effectifs
aux.long.q <- aux.long %>%
group_by(clust, variable, value) %>%
mutate(count = n_distinct(id.s)) %>%
distinct(clust, variable, value, count)
# avec fréquences
aux.long.p <- aux.long.q %>%
group_by(clust, variable) %>%
mutate(perc = count/sum(count)) %>%
arrange(clust)
Lev <- NULL
for (j in 1:ncol(Data)) Lev <- c(Lev, levels(Data[, j]))
Jaux <- NULL
for (j in 1:length(J)) {
Jaux <- c(Jaux, which(aux.long.p$variable == colnames(Data)[J[j]]))
}
gaux <- ggplot(aux.long.p[Jaux, ], aes(x = clust, y = value)) + geom_tile(aes(fill = perc)) +
scale_fill_gradient2(low = "white", mid = "blue", high = "red") + theme_minimal()
return(list(gaux = gaux, eff = aux.long.q, freq = aux.long.p))
}
fviz_pca_ind(res.acp,axes=c(1,2),geom=c("point"),col.ind=apply(resfcm$u, 1, max))+
scale_color_gradient2(low="white", mid="blue",high="red", midpoint=0.8, space = "Lab")
zoo<- read.table("zoo.txt")
# A COMPLETER
zoo<- read.table("zoo-dataTP.txt")
# A COMPLETER
zoo<- read.table("zoo-dataTP.txt")
str(zoo)
res.mca<-MCA(zoo)
# A COMPLETER
res.mca<-MCA(zoo, quali.sup = 7)
# A COMPLETER
zoo<- read.table("zoo-dataTP.txt")
head(zoo)
zoo<- read.table("zoo-dataTP.txt")
head(zoo)
zoo = as.factor(zoo)
res.mca<-MCA(zoo)
# A COMPLETER
zoo<- read.table("zoo-dataTP.txt")
head(zoo)
zoo = as.factor(zoo)
str(zoo)
zoo<- read.table("zoo-dataTP.txt")
zoo<- read.table("zoo-dataTP.txt")
for (j in 1:ncol(zoo)) {
zoo[,j] = as.factor(zoo[,j])
}
res.mca<-MCA(zoo)
# A COMPLETER
res.mca<-MCA(zoo, quali.sup = 7)
# A COMPLETER
res.mca<-MCA(zoo)
# A COMPLETER
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(mclust)
library(cluster)
library(factoextra)
library(FactoMineR)
library(ppclust)
library(reticulate)
library(ggplot2)
library(reshape)
library(corrplot)
library(gridExtra)
library(circlize)
library(viridis)
library(reshape2)
library(klaR)
wine <-read.table("wine.txt")
str(wine)
wine$Qualite <- as.factor(wine$Qualite)
wine$Type <- factor(wine$Type)
levels(wine$Type) = c("Rouge", "Blanc")
str(wine)
table(wine$Type)
boxplot(wine)
pairs(wine)
corrplot(cor(wine[,3:8]), method = "ellipse")
ggplot(wine, aes(x=Type))+ geom_bar() + ylab("")+ ggtitle("Effectifs")
ggplot(wine, aes(x=Qualite))+ geom_bar() + ylab("")+ ggtitle("Effectifs")
res.acp = PCA(wine, scale.unit = TRUE, ncp = ncol(6), quali.sup = 1:2, graph = TRUE, axes = c(1,2))
fviz_pca_ind(res.acp, axes=c(1,2), geom=c("point"), habillage = wine$Type)
fviz_pca_ind(res.acp, geom=c("point"), habillage = wine$Qualite)
fviz_eig(res.acp)
wine_quant = wine[,3:8]
wine_quant = scale(wine_quant, center = T, scale = T)
help(kmeans)
reskmeans<-kmeans(wine_quant, centers = 3)
help(kmeans)
reskmeans<-kmeans(wine_quant, centers = 3)
reskmeans
help(kmeans)
reskmeans<-kmeans(wine_quant, centers = 3)
reskmeans$centers
fviz_cluster(reskmeans, data = wine_quant, ellipse.type = "norm", labelsize = 8, geom = c("point"))+ggtitle("")
table(reskmeans$cluster)
help(kmeans)
reskmeans<-kmeans(wine_quant, centers = 3)
reskmeans
reskmeans$centers
